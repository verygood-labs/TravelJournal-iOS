//
//  AddTripViewModel.swift
//  TravelJournal-iOS
//
//  Created by John Apale on 1/21/26.
//

import Foundation
import Combine

@MainActor
final class AddTripViewModel: ObservableObject {
    // MARK: - Published Properties
    
    // Search state
    @Published var searchText = ""
    @Published var searchResults: [LocationSearchResult] = []
    @Published var isSearching = false
    
    // Stops
    @Published var stops: [TripStop_Draft] = []
    
    // Trip details
    @Published var tripTitle = ""
    @Published var tripDescription = ""
    
    // Submission state
    @Published var isSubmitting = false
    @Published var error: String?
    
    // MARK: - Services
    private let placeService = PlaceService.shared
    private let tripService = TripService.shared
    
    // MARK: - Search Debounce
    private var searchTask: Task<Void, Never>?
    
    // MARK: - Computed Properties
    
    var autoGeneratedTitle: String {
        guard !stops.isEmpty else { return "" }
        
        let cityNames = stops.map { $0.city.name }
        
        if cityNames.count == 1 {
            return "\(cityNames[0]) Trip"
        } else {
            return cityNames.joined(separator: " â†’ ") + " Trip"
        }
    }
    
    var displayTitle: String {
        tripTitle.isEmpty ? autoGeneratedTitle : tripTitle
    }
    
    var canSave: Bool {
        !stops.isEmpty
    }
    
    var totalDuration: Int? {
        guard let firstStart = stops.map({ $0.startDate }).min(),
              let lastEnd = stops.map({ $0.endDate }).max() else {
            return nil
        }
        
        let days = Calendar.current.dateComponents([.day], from: firstStart, to: lastEnd).day ?? 0
        return days + 1
    }
    
    var dateRangeFormatted: String? {
        guard let firstStart = stops.map({ $0.startDate }).min(),
              let lastEnd = stops.map({ $0.endDate }).max() else {
            return nil
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd"
        
        let startStr = formatter.string(from: firstStart)
        let endStr = formatter.string(from: lastEnd)
        
        let yearFormatter = DateFormatter()
        yearFormatter.dateFormat = "yyyy"
        let year = yearFormatter.string(from: lastEnd)
        
        return "\(startStr) - \(endStr), \(year)"
    }
    
    var countriesCount: Int {
        let uniqueCountries = Set(stops.compactMap { $0.city.countryCode })
        return uniqueCountries.count
    }
    
    var startDateFormatted: String? {
        guard let startDate = stops.map({ $0.startDate }).min() else {
            return nil
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd, yyyy"
        return formatter.string(from: startDate)
    }

    var endDateFormatted: String? {
        guard let endDate = stops.map({ $0.endDate }).max() else {
            return nil
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd, yyyy"
        return formatter.string(from: endDate)
    }
    
    // MARK: - Search
    
    func onSearchTextChanged() {
        // Cancel previous search
        searchTask?.cancel()
        
        let query = searchText.trimmingCharacters(in: .whitespaces)
        
        // Clear results if query is too short
        guard query.count >= 2 else {
            searchResults = []
            isSearching = false
            return
        }
        
        // Debounce search
        searchTask = Task {
            isSearching = true
            
            // Wait 300ms before searching
            try? await Task.sleep(nanoseconds: 300_000_000)
            
            // Check if task was cancelled
            guard !Task.isCancelled else { return }
            
            do {
                let results = try await placeService.searchCities(query: query, limit: 10)
                
                // Filter out already added cities
                let existingIds = Set(stops.map { $0.city.id })
                searchResults = results.filter { !existingIds.contains($0.id) }
            } catch {
                print("Search error: \(error)")
                searchResults = []
            }
            
            isSearching = false
        }
    }
    
    // MARK: - Stops Management
    
    func addStop(city: LocationSearchResult) {
        // Default dates: today to tomorrow (or day after last stop)
        let startDate: Date
        let endDate: Date
        
        if let lastStop = stops.last {
            // Start day after last stop ends
            startDate = Calendar.current.date(byAdding: .day, value: 1, to: lastStop.endDate) ?? Date()
            endDate = Calendar.current.date(byAdding: .day, value: 2, to: lastStop.endDate) ?? Date()
        } else {
            startDate = Date()
            endDate = Calendar.current.date(byAdding: .day, value: 1, to: Date()) ?? Date()
        }
        
        let newStop = TripStop_Draft(
            city: city,
            startDate: startDate,
            endDate: endDate
        )
        
        stops.append(newStop)
        
        // Clear search
        searchText = ""
        searchResults = []
    }
    
    func removeStop(at index: Int) {
        guard index >= 0 && index < stops.count else { return }
        stops.remove(at: index)
    }
    
    func removeStop(_ stop: TripStop_Draft) {
        stops.removeAll { $0.id == stop.id }
    }
    
    // MARK: - Save Trip
    func saveTrip() async -> Trip? {
        guard canSave else { return nil }
        
        isSubmitting = true
        error = nil
        
        do {
            // Calculate overall date range
            let startDate = stops.map { $0.startDate }.min()
            let endDate = stops.map { $0.endDate }.max()
            
            // Build initial stops from OSM data
            let initialStops = stops.map { stop in
                CreateTripStopRequest(
                    osmType: stop.city.osmType,
                    osmId: stop.city.osmId,
                    arrivalDate: stop.startDate
                )
            }
            
            // Create the trip with stops in one atomic request
            let createdTrip = try await tripService.createTrip(
                title: displayTitle,
                description: tripDescription.isEmpty ? nil : tripDescription,
                startDate: startDate,
                endDate: endDate,
                initialStops: initialStops
            )
            
            isSubmitting = false
            return createdTrip
            
        } catch let apiError as APIError {
            error = apiError.localizedDescription
            isSubmitting = false
            return nil
        } catch {
            self.error = "Failed to create trip. Please try again."
            isSubmitting = false
            return nil
        }
    }
}
